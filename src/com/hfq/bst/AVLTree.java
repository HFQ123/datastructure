package com.hfq.bst;import java.util.Comparator;/** * @Created by hfq on 2020/4/26 * @used to: */public class AVLTree <E> extends BinarySearchTree <E> {    public AVLTree(Comparator<E> comparator){        super(comparator);    }    public AVLTree() {    }    @Override    protected Node createNode(E element, Node<E> parent) {        return new AVLNode(element, parent);    }    /**     *                                               | (上面可能还有父节点，下面是失衡的子树)     *                                            ┌──7─┐ (grand，第一个失衡的节点)     *                                            │    │     *                                        ┌─4─┐    ┌─9─┐    在这里，4是parent，插入节点。因为4的高度>9 ，说明新添加节点是在4这边。。     *                                        │ （这中间可能相隔多个父节点..）     *                                      ┌─2─┐ (node)     * AVL树添加节点后的操作     * 添加节点后要做两件事：     * + 更新部分节点的高度：添加一个节点后，只会影响其祖先节点的高度     * + 维持 AVL树添加node节点后 的平衡：需要找到新添加节点从下到上第一个失衡的祖父节点     * 注意：子树恢复平衡后，其祖先节点的高度就不用更新了，因为调整后其高度与添加前高度一样（看PPT的图例调整前后高度的对比）     * @param node     */    @Override    protected void afterAdd(Node node) {        while ((node = node.parent) != null){ //往上找祖父结点            if(isBalanced(node)){  //更新高度                updateHeight(node);            }else {                rebalance(node); //恢复平衡，此时node，就是上图例中的grand                break;           //子树恢复平衡后(这棵树的父节点是由新添加节点开始从下到上第一个不平衡的节点)整棵树都恢复平衡了            }        }    }    /**     * 计算AVL树的节点高度     * @param node     */    private void updateHeight(Node node){        ((AVLNode)node).updateHeight();    }    private boolean isBalanced(Node node){        return ((AVLNode)node).isBalanced();    }    /**     * 恢复平衡     * @param grand 由AVL树中新添加节点开始从下到上第一个不平衡的节点。PPT中用符号“g”表示     */    private void rebalance(Node grand){        AVLNode parent = ((AVLNode)grand).tallerChild();        AVLNode node = parent.tallerChild();        if(parent.isLeftChild()){ //L            if(node.isLeftChild()){ //LL                rotateRight(grand);            }else { //LR                rotateLeft(parent);                rotateRight(grand);            }        }else {  //R            if(node.isLeftChild()){ //RL                rotateRight(parent);                rotateLeft(grand);            }else { //RR                rotateLeft(grand);            }        }    }    /**     * 左旋，主要涉及三个节点，grand,parent,child，分别对应ppt里g,p,T1     * 更改grand的孩子、grand.parent的孩子、parent的孩子     * 更改grand的父亲、parent的父亲、T1的父亲     * @param grand     */    private void rotateLeft(Node grand){        Node parent = grand.right;        Node child = parent.left; //child就是ppt图例中的T1,需要注意它可能是null        //1、更改grand节点的right指向        grand.right = child;        //2、更改parent节点的left指向        parent.left = grand;        //一、更改parent节点的parent指向，因为parent节点替代了原来grand的位置        parent.parent = grand.parent;        //3、更改原grand节点的父节点的孩子指向，因为parent节点替代了原来grand的位置        if(((AVLNode)grand).isLeftChild()){            grand.parent.left = parent;        }else if(((AVLNode) grand).isRightChild()){            grand.parent.right = parent;        }else { //说明原来grand就是根节点，没有父节点            this.root = parent; //则设置root为parent，因为parent节点替代了原来grand的位置        }        //二、更改grand的parent指向        grand.parent = parent;        //三、更改child的parent指向，前面赋值过child=grand.right        if(child!=null){            child.parent = grand;        }        updateHeight(grand);        updateHeight(parent);    }    /**     * 右旋，同上左旋，妙记不遗漏：更换三个节点的子，更换三个节点的父，先后更新两个节点高度     * @param grand     */    private void rotateRight(Node <E> grand){        Node parent = grand.left;        Node child = parent.left;        parent.right = grand;        grand.left = child;        //后面的代码其实和左旋中是一样的        parent.parent = grand.parent;        if(((AVLNode)grand).isLeftChild()){            grand.parent.left = parent;        }else if(((AVLNode) grand).isRightChild()){            grand.parent.right = parent;        }else {            this.root = parent;        }        grand.parent = parent;        if(child!=null){            child.parent = parent;        }        updateHeight(grand);        updateHeight(parent);    }    protected static class AVLNode extends Node{        int height = 1; //记录节点高度        public AVLNode(Object element, Node parent) {            super(element, parent);        }        /**         * 计算该节点的平衡因子         * @return         */        public int balanceFactor(){            int leftHeight = this.left==null ? 0 : ((AVLNode)this.left).height;            int rightHeight = this.right==null ? 0 : ((AVLNode)this.right).height;            return leftHeight-rightHeight;        }        /**         * 判断该节点是否平衡         * @return         */        public boolean isBalanced(){            return Math.abs(this.balanceFactor()) <= 1;        }        /**         * 更新该节点高度         */        public void updateHeight(){            int leftHeight = this.left==null ? 0 : ((AVLNode)this.left).height;            int rightHeight = this.right==null ? 0 : ((AVLNode)this.right).height;            this.height = Math.max(leftHeight,rightHeight) + 1;        }        /**         * 返回高度更高的子结点         * @return         */        public AVLNode tallerChild(){            int leftHeight = this.left==null ? 0 : ((AVLNode)this.left).height;            int rightHeight = this.right==null ? 0 : ((AVLNode)this.right).height;            if(leftHeight > rightHeight)                return (AVLNode)this.left;            return (AVLNode)this.right;        }        /**         * 判断其是否为父节点的左孩子         * @return         */        public boolean isLeftChild(){            return this.parent!=null &&  this == this.parent.left;        }        /**         * 判断其是否为父节点的右孩子         * @return         */        public boolean isRightChild(){            return this.parent!=null &&  this == this.parent.right;        }    }}